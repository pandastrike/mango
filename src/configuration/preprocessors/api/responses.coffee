possibleResponses = require "./possible-responses"
{cat, isArray} = require "fairmont"

# Gateway does not, by default, support arbitrary HTTP responses.  Each response
# type must be explicitly specified in an API method description.  The code
# below adds these responses.  In addition to the expected response, this
# adds error responses (ex 404, 403) to the API method descriptions.
module.exports = (description) ->

  # Array of possible responses generated by the Lambda integration
  addIntegrationResponses = (method, methodList) ->
    addDefault = (status) ->
      response =
        StatusCode: status
        ResponseParameters:
          "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
          "method.response.header.Access-Control-Allow-Methods": "'#{methodList}'"
          "method.response.header.Access-Control-Allow-Origin": "'*'"

      if method.signatures.accept?
        response.ResponseParameters["method.response.header.Content-Type"] = "'#{method.signatures.accept}'"

        # FIXME: the following is very hackish, formalize our integration
        # response mapping template
        if method.signatures.accept == "text/html"
          # ammend response object w/ response template (velocity code)
          response.ResponseTemplates =
            "text/html": """#set($inputRoot = $input.path('$'))
              $inputRoot.body"""
      response

    addOthers = (statuses) ->
      out = []
      for code in statuses
        out.push(
          StatusCode: code
          SelectionPattern: possibleResponses[code]
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
            "method.response.header.Access-Control-Allow-Methods": "'#{methodList}'"
            "method.response.header.Access-Control-Allow-Origin": "'*'"
        )
      out

    s = method.signatures.response.status
    if !isArray s
      return [addDefault s] # Only one response specified.
    else
      # Start by adding the "default" response, then all others.
      [d, others...] = s
      return cat [addDefault d], (addOthers others)

  # Array of possible responses whitelisted by the Method response, coming from
  # the Integration response.
  addMethodResponses = (method) ->
    addDefault = (status) ->
      response =
        StatusCode: status
        ResponseParameters:
          "method.response.header.Access-Control-Allow-Headers": true
          "method.response.header.Access-Control-Allow-Methods": true
          "method.response.header.Access-Control-Allow-Origin": true

      if method.signatures.accept?
        response.ResponseParameters["method.response.header.Content-Type"] = true
      return response

    addOthers = (statuses) ->
      out = []
      for code in statuses
        out.push(
          StatusCode: code
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": true
            "method.response.header.Access-Control-Allow-Methods": true
            "method.response.header.Access-Control-Allow-Origin": true
        )
      out

    s = method.signatures.response.status
    if !isArray s
      return [addDefault s] # Only one response specified.
    else
      # Start by adding the "default" response, then all others.
      [d, others...] = s
      return cat [addDefault d], (addOthers others)

  {resources} = description
  for r, resource of resources
    for httpMethod, method of resource.methods
      resources[r].methods[httpMethod].IntegrationResponses = addIntegrationResponses method, resource.methodList
      resources[r].methods[httpMethod].MethodResponses = addMethodResponses method
      delete method.signatures

  description.resources = resources
  description
