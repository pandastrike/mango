"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = undefined;

var _https = require("https");

var _https2 = _interopRequireDefault(_https);

var _url = require("url");

var _url2 = _interopRequireDefault(_url);

var _awsSdk = require("aws-sdk");

var _awsSdk2 = _interopRequireDefault(_awsSdk);

var _fairmont = require("fairmont");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Generated by CoffeeScript 2.1.0
// This is the Lambda Killer custom resource.  It targes all the Lambdas in the Sky deployment and deletes them.
var LAMBDA, deleteAll, handler, lambda, liftModule, sendResponse;

liftModule = function (m) {
  var k, lifted, v;
  lifted = {};
  for (k in m) {
    v = m[k];
    lifted[k] = (0, _fairmont.isFunction)(v) ? (0, _fairmont.lift)((0, _fairmont.bind)(v, m)) : v;
  }
  return lifted;
};

LAMBDA = liftModule(new _awsSdk2.default.Lambda());

lambda = function () {
  var Delete, list;
  list = (() => {
    var _ref = _asyncToGenerator(function* (fns = [], marker) {
      var Functions, NextMarker, params;
      params = {
        MaxItems: 100
      };
      if (marker) {
        params.Marker = marker;
      }
      ({ NextMarker, Functions } = yield LAMBDA.listFunctions(params));
      fns = (0, _fairmont.cat)(fns, Functions);
      if (NextMarker) {
        return yield list(fns, NextMarker);
      } else {
        return fns;
      }
    });

    return function list() {
      return _ref.apply(this, arguments);
    };
  })();
  Delete = (() => {
    var _ref2 = _asyncToGenerator(function* (name) {
      return yield LAMBDA.deleteFunction({
        FunctionName: name
      });
    });

    return function Delete(_x) {
      return _ref2.apply(this, arguments);
    };
  })();
  return {
    list,
    delete: Delete
  };
}();

deleteAll = (() => {
  var _ref3 = _asyncToGenerator(function* (stackName) {
    var isOurs, lambdas, name, names;
    // Get names of all Lambdas that are part of this environment
    lambdas = yield lambda.list();
    names = (0, _fairmont.collect)((0, _fairmont.project)("FunctionName", lambdas));
    isOurs = function (str) {
      return RegExp(`^${stackName}.+`).test(str);
    };
    names = (0, _fairmont.collect)((0, _fairmont.select)(isOurs, names));
    return yield Promise.all(function () {
      var i, len, results;
      results = [];
      for (i = 0, len = names.length; i < len; i++) {
        name = names[i];
        results.push(lambda.delete(name));
      }
      return results;
    }());
  });

  return function deleteAll(_x2) {
    return _ref3.apply(this, arguments);
  };
})();

exports.handler = handler = (() => {
  var _ref4 = _asyncToGenerator(function* (event, context) {
    var e;
    console.log("handling event for", event);
    // For Non-Delete requests, immediately send a SUCCESS response.
    if (event.RequestType !== "Delete") {
      sendResponse(event, context, "SUCCESS");
      return;
    }
    try {
      yield deleteAll(event.StackName);
      return sendResponse(event, context, "SUCCESS");
    } catch (error) {
      e = error;
      return sendResponse(event, context, "FAILED", {
        Error: e
      });
    }
  });

  return function handler(_x3, _x4) {
    return _ref4.apply(this, arguments);
  };
})();

// CloudFormation waits for a result JSON object to be sent to the pre-signed S3 bucket URL.
sendResponse = function (event, context, responseStatus, responseData) {
  var options, parsedUrl, request, responseBody;
  responseBody = JSON.stringify({
    Status: responseStatus,
    Reason: "See the details in CloudWatch Log Stream: " + context.logStreamName,
    PhysicalResourceId: context.logStreamName,
    StackId: event.StackId,
    RequestId: event.RequestId,
    LogicalResourceId: event.LogicalResourceId,
    Data: responseData
  });
  console.log(responseBody);
  parsedUrl = _url2.default.parse(event.ResponseURL);
  options = {
    hostname: parsedUrl.hostname,
    port: 443,
    path: parsedUrl.path,
    method: "PUT",
    headers: {
      "content-type": "",
      "content-length": responseBody.length
    }
  };
  request = _https2.default.request(options, function () {
    return context.done();
  });
  request.on("error", function (e) {
    console.log("sendResponse Error:" + e);
    return context.done();
  });
  request.write(responseBody);
  return request.end();
};

exports.handler = handler;