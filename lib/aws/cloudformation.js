// Generated by CoffeeScript 1.12.0
(function() {
  var async, first, ref, sleep,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require("fairmont"), async = ref.async, first = ref.first, sleep = ref.sleep;

  module.exports = async(function*(env, config) {
    var cfo, create, deleteWait, destroy, generateTemplate, getApiUrl, getStack, hardUpdate, name, postDelete, postPublish, publish, publishWait, softUpdate, src, update;
    cfo = (yield require("./index")(config.aws.region)).cfo;
    src = (yield require("./app-root")(env, config));
    name = config.name + "-" + env;
    generateTemplate = function() {
      return {
        StackName: name,
        TemplateBody: config.aws.cfoTemplate,
        Capabilities: ["CAPABILITY_IAM"]
      };
    };
    hardUpdate = function(str) {
      var R, k, out, retain, v;
      retain = ["API", "LambdaRole", "CFRDistro", "DNSRecords"];
      out = JSON.parse(str);
      R = out.Resources;
      for (k in R) {
        v = R[k];
        if (!(indexOf.call(retain, k) >= 0) && !k.match(/^Mixin/)) {
          delete R[k];
        }
      }
      out.Resources = R;
      return JSON.stringify(out);
    };
    softUpdate = function(str) {
      var R, k, out, retain, v;
      retain = ["API", "LambdaRole", "Deployment", "CFRDistro", "DNSRecords"];
      out = JSON.parse(str);
      R = out.Resources;
      for (k in R) {
        v = R[k];
        if (!(indexOf.call(retain, k) >= 0) && !k.match(/^Mixin/)) {
          delete R[k];
        }
      }
      R.Deployment.DependsOn = [];
      out.Resources = R;
      return JSON.stringify(out);
    };
    getStack = async(function*(id) {
      try {
        return first(((yield cfo.describeStacks({
          StackName: id
        }))).Stacks);
      } catch (error) {
        return false;
      }
    });
    getApiUrl = async(function*() {
      var apiID, data, params;
      params = {
        LogicalResourceId: "API",
        StackName: name
      };
      data = (yield cfo.describeStackResource(params));
      apiID = data.StackResourceDetail.PhysicalResourceId;
      return "https://" + apiID + ".execute-api." + config.aws.region + ".amazonaws.com/" + env;
    });
    update = async(function*(updates) {
      var desired, params;
      console.log("Existing stack detected. Updating.");
      params = generateTemplate();
      desired = params.TemplateBody;
      params.TemplateBody = indexOf.call(updates, "GW") >= 0 ? hardUpdate(desired) : softUpdate(desired);
      yield cfo.updateStack(params);
      yield publishWait(name);
      params.TemplateBody = desired;
      return (yield cfo.updateStack(params));
    });
    create = async(function*() {
      console.log("Creating fresh stack.");
      return (yield cfo.createStack(generateTemplate()));
    });
    publish = async(function*() {
      var StackId, needsDeploy, ref1;
      console.log("Scanning AWS for current deploy.");
      needsDeploy = (yield src.prepare());
      if (!needsDeploy) {
        console.log(name + " is up to date.");
        return false;
      }
      if (ref1 = (yield getStack(name)), StackId = ref1.StackId, ref1) {
        yield update(needsDeploy);
      } else {
        StackId = (yield create()).StackId;
      }
      return StackId;
    });
    destroy = async(function*() {
      var StackId;
      StackId = (yield getStack(name)).StackId;
      yield cfo.deleteStack({
        StackName: name
      });
      return StackId;
    });
    publishWait = async(function*(id) {
      var StackStatus, StackStatusReason, ref1;
      while (true) {
        ref1 = (yield getStack(id)), StackStatus = ref1.StackStatus, StackStatusReason = ref1.StackStatusReason;
        switch (StackStatus) {
          case "CREATE_IN_PROGRESS":
          case "UPDATE_IN_PROGRESS":
          case "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS":
            yield sleep(5000);
            break;
          case "CREATE_COMPLETE":
          case "UPDATE_COMPLETE":
            return true;
          default:
            console.error("Stack creation failed. Aborting.", StackStatus, StackStatusReason);
            throw new Error();
        }
      }
    });
    deleteWait = async(function*(id) {
      var s;
      while (true) {
        s = (yield getStack(id));
        if (!s) {
          return true;
        }
        switch (s.StackStatus) {
          case "DELETE_IN_PROGRESS":
            yield sleep(5000);
            break;
          case "DELETE_COMPLETE":
            return true;
          default:
            console.warn("Stack deletion failed.", s.StackStatus, s.StackStatusReason);
            return false;
        }
      }
    });
    postPublish = async(function*() {
      yield src.syncMetadata();
      if (!config.aws.environments[env].cache) {
        console.log("Your API is online and ready at the following endpoint:");
        return console.log("  " + ((yield getApiUrl())));
      }
    });
    postDelete = async(function*() {
      return (yield src.destroy());
    });
    return {
      publish: publish,
      "delete": destroy,
      publishWait: publishWait,
      deleteWait: deleteWait,
      postPublish: postPublish,
      postDelete: postDelete
    };
  });

}).call(this);
